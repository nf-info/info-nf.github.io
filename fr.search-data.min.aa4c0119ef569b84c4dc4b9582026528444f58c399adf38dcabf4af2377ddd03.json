[{"id":0,"href":"/fr/docs/spe/01-complexite/","title":"01 Complexite","section":"Spe","content":" Introduction # La complexité d\u0026rsquo;un algorithme est une mesure des ressources nécessaires à son exécution, il y a deux ressources principales:\nComplexité spatiale: quantité de mémoire requise.\nComplexité temporelle: temps de calcul à prévoir.\nLe but de ces mesures est de comparer les algorithmes pour pouvoir identifier l\u0026rsquo;algorithme le plus efficace.\nOn ne mesure pas les valeurs exactes (le nombre d\u0026rsquo;octets nécessaires ou le nombre de secondes) mais uniquement des ordres de grandeurs en fonction des paramètres d\u0026rsquo;entrée.\nExemple: # On souhaite comparer deux algorithmes qui permettent de déterminer si un entier naturel n est premier ou pas:\n:::: box ::: {.columns-flow count=\u0026ldquo;2\u0026rdquo;}\nPour cette première version on test si: $$\\left( \\forall i \\in ⟦2,n⟦ \\right)\\mspace{13mu} i \\mid n$$\n# def test_premier_version_1(n): flag = True for i in range(2,n): if (n % i == 0): flag = False return flag Pour la deuxième version on test si: $$\\left( \\forall i \\in ⟦2,\\sqrt{n}⟧ \\right)\\mspace{13mu} i \\mid n$$\nfrom math import sqrt, ceil def test_premier_version_2(n): flag = True for i in range(2, ceil(sqrt(n))): if (n % i == 0): flag = False return flag ::: ::::\n** Quelle version est la plus rapide ? **\nL\u0026rsquo;intuition nous dis que la deuxième version est la plus rapide, mais pour mesurer ça, on s\u0026rsquo;appuie sur la notion d\u0026rsquo;instruction élémentaire.\nCalcul de Complexité # Instructions élémentaires # Il est nécessaire de préciser les instructions élémentaires disponibles, c\u0026rsquo;est-à-dire les opérations de coût constant:\nopérations arithmétiques et logiques: a + b, a - b, a / b, a and b\ncomparaisons de données élémentaires: a \u0026lt; b, a == b\ntransferts de données simples: a = 42\ninstructions de contrôle: if, else, while, for, return, def\nMéthode de calcul # On énuméré le nombre d\u0026rsquo;instructions élémentaires qui seront exécutées dans l\u0026rsquo;algorithme, en utilisant les règles suivantes:\nRègles # Pour les boucles for:\nfor i in range(n): # 1 # Bloc a # cout: T_a(i) La complexité totale de la boucle est de: $$C(n) = O(1) + O\\left( \\sum_{i = 0}^{n - 1}T_{a}(i) \\right)$$ Pour les boucles while:\nwhile (condition): # 1 # Bloc a # T_a(m) Il n\u0026rsquo;y a pas de méthode sur, mais on essaye de trouver le nombre d\u0026rsquo;itérations totales que fera la boucle, selon la condition. Ce nombre dépend des entrées, notant le $f(n)$\nLa complexité est donc: $$C(n) = O(1) + O\\left( \\sum_{i = 0}^{f(n)}T_{a}(i) \\right)$$\nPour les conditions:\nif (condition_1): # 1 # Bloc a # T_a(n) elif (condition_2): # 1 # Bloc b # T_b(n) else: # 1 # Bloc c # T_c(n) Puisqu\u0026rsquo;on s\u0026rsquo;intéresse a la complexité au pire des cas, on utilise le max des différentes complexités des branches: $C(n) = O(1) + O\\left( \\max\\left\\lbrack T_{a}(n),T_{b}(n),T_{c}(n) \\right\\rbrack \\right)$\nExemple # def test_premier_version_1(n): # 1 flag = True # 1 for i in range(2, n): # 1 if (n % i == 0): # 1 flag = False # 1 return flag # 1 Après avoir énumérer les instructions élémentaire ci-dessus, on calcul la complexité $C(n)$: $$C(n) = O(1) + O(1) + O(1) + \\sum_{i = 2}^{n - 1}O(1)$$ $$C(n) = O\\left( 3 + (n - 2) \\right)$$ On utilise la propriété suivante: $$f = o(g) \\Rightarrow O(f + g) = O(g)$$ On obtient: $$C(n) = O(n)$$\nClasses de complexité # Le graphe suivant montre les comportements asymptotiques des différentes classes de complexité:\nClasse de complexité\nPour estimer le temps d\u0026rsquo;exécution $T$ d\u0026rsquo;un algorithme pour une taille d\u0026rsquo;entrée $n$, on se base sur sa complexité $C(n)$ qui représente le nombre d\u0026rsquo;instructions exécutées, et on utilise la fréquence du processeur $f$ qui est le nombre d\u0026rsquo;instructions exécutées par seconde. $$T = \\frac{C(n)}{f}$$\nPour un processeur de fréquence 1GHz on obtient les valeurs suivantes:\nClasse de complexité\nExercices # Calculez les complexités des fonctions suivantes:\ndef f1(n): for i in range (n): for j in range(n): print(\u0026#34;Hello\u0026#34;) def f2(n): for i in range(n): for j in range(i): print(\u0026#34;Hello\u0026#34;) def f3(n): k=n while (k \u0026gt; 1): k = k // 2 def f4(n, m): while n + m \u0026gt; 1: if (n + m) % 2 == 0: n -= 1 else: m -= 1 def f5(n): for i in range(n*n): for j in range(i): print (\u0026#34;Hello\u0026#34;) def f6(n, m): for i in range(n): t = 1 while t \u0026lt; m: print (\u0026#34;Hello\u0026#34;) t = t * 2 def f7(n, L): for i in range(n): if i % 2 == 0: sorted(L) title: [ **Attention : ** ], [ Les instructions suivantes ne sont pas élémentaire:\nrecherche dans une liste; x in L, L.index(x), L.remove(x)\ntransferts de données composées; T = L.copy(), chaine = f.read()\nEn général, il faut se méfier de tout appel a des fonctions prédéfinis. ]\nComplexité des fonctions récursives # On applique les mêmes étapes:\nExemple # On note $C(n)$ la complexité de la fonction suivante:\ndef factorielle(n): # 1 if n \u0026lt;= 1: # 1 return 1 # 1 return n * factorielle(n-1) # 1 + C(n-1) Le coût de l\u0026rsquo;appel récursif factorielle(n-1) est $C(n - 1)$.\nOn calcul alors la complexité $C(n)$:\n$$C(n) = O(1 + 1 + 1) + C(n - 1)$$ Et on a $$C(1) = O(1 + 1 + 1) = O(1)$$\nOn peut alors montrer par récurrence que: $$C(n) = O(n)$$\nRègles # Pour les fonctions récursives, le calcul de complexité donne souvent une formule de récurrence, il faut donc la résoudre pour trouver la formule du terme général.\ntitle: [ Hors-programme: ], color: \u0026ldquo;blue\u0026rdquo;, radius: 2pt, width: auto [\nOn peut s\u0026rsquo;appuyer sur le master théorème pour trouver rapidement la formule générale.\nPour $$\\begin{cases} T(n) = aT\\left( \\frac{n}{b} \\right) + O\\left( n^{k} \\right) \\ T(1) = O(1) \\end{cases}$$ On compare $k$ avec $\\log_{\\left{ b \\right}}(a)$:\n$$ T(n) = \\begin{cases} O\\left( n^{k} \\right)\\mspace{90mu} \u0026amp; \\text{ si }\\mspace{15mu}\\log_{b}(a) \u0026lt; k \\ O\\left( n^{k}\\log_{b}(n) \\right) \u0026amp; \\text{ si }\\mspace{15mu}\\log_{b}(a) = k \\ O\\left( n^{\\log_{b}(a)} \\right) \u0026amp; \\text{ si }\\mspace{15mu}\\log_{b}(a) \u0026gt; k \\end{cases}$$ ]\nExercices # def f8(n): if (n == 0): return 1 return f8(n-1) + f8(n-1) def f9(n): if (n == 0): return 1 resultat = f9(n-1) return resultat + resultat def puissance_v1(a,b): if (b == 0): return 1 return a * puissance_v1(a, b-1) def puissance_v2(a,b): if (b == 0): return 1 if (b % 2 == 0): return puissance_v2(a, b//2) ** 2 if (b % 2 == 1): return a * puissance_v2(a, b//2) ** 2 def fibonacci(n): if (n \u0026lt;= 1): return 1 return fibonacci(n-1) + fibonacci(n-2) $$\n"},{"id":1,"href":"/fr/docs/spe/02-algorithme_de_tri/","title":"02 Algorithme De Tri","section":"Spe","content":" Algorithmes de tri # On souhaite réordonner une collection d\u0026rsquo;éléments suivant une relation d\u0026rsquo;ordre déterminée. On peut, sans perte de généralité, simplifier l\u0026rsquo;étude des différentes méthodes de tri en se limitant aux listes d\u0026rsquo;entiers, qu\u0026rsquo;on souhaite trier par ordre croissant.\nIl s\u0026rsquo;agit donc d\u0026rsquo;élaborer une fonction tri(L) qui prend en paramètre une liste d\u0026rsquo;entier L et qui permet de trier cette liste, et de renvoyer la liste triée.\ndef tri(L): # ... return L # Programme de test L = [9, 5, 8, 1, 12, 4] tri(L) print(L) Dans toute la suite, on pose $n = \\operatorname{len}(L)$.\nTri par sélection # Le tri par sélection consiste a sélectionner dans chaque itération le prochain élément a placer dans la liste triee, qui est le minimum des éléments non encore tries. C\u0026rsquo;est a dire, en faisant varier $i$ de $0$ a $n$, a chaque itération, on va remettre le $i^{\\text{eme}}$ élément de la liste triée, qui est min(L[i:n]), a sa place L[i].\nImplémentation # def tri_selection(L): # 1 for i in range(len(L)-1): # 1 indice_min = i # 1 for j in range(i+1,len(L)): # 1 if L[j] \u0026lt; L[indice_min] : # 1 indice_min = j # 1 L[i],L[indice_min] = L[indice_min],L[i] # 1 Complexité # On a deux boucles imbriquées, la boucle intérieure comporte des instructions de complexité $O(1)$, et se répète n-i fois, la boucle extérieure se répété pour i=0 a i=n, donc la complexité est $O\\left( n^{2} \\right)$.\nTri par insertion # Le tri par insertion consiste a insérer, un par un, les éléments de la liste non triée dans la liste triée.\nImplémentation # def insertionSort(L): for i in range(1, len(L)): cle = L[i] j = i-1 while j \u0026gt;= 0 and cle \u0026lt; L[j] : L[j + 1] = L[j] j -= 1 L[j + 1] = cle Complexité # La complexité de la boucle intérieure dépend de l\u0026rsquo;état de la liste.\nAu meilleur des cas : La liste est déjà triée, la boucle while ne s\u0026rsquo;exécute pas. Complexité $O(n)$.\nAu pire des cas : La liste est triée a l\u0026rsquo;ordre inverse, la boucle while se répété i fois, donc la complexité est $O\\left( n^{2} \\right)$.\nTri a bulles # Le tri a bulles consiste a faire plusieurs passages de comparaisons deux-a-deux, ou on va échanger deux éléments si il ne sont pas au bon ordre. Les éléments vont se déplacer petit a petit jusqu\u0026rsquo;à trouver leurs places. Ce déplacement global des éléments ressemble aux déplacements de bulles qui remontent dans un liquide.\nImplémentation # def bubbleSort(L): n = len(L) for i in range(n): for j in range(0, n-i-1): if L[j] \u0026gt; L[j+1]: L[j], L[j+1] = L[j+1], L[j] Complexité # La complexité est $O\\left( n^{2} \\right)$\nTri par fusion # Le tri par fusion est un tri récursif, ou on découpe la liste en deux, on trie chaque partie a l\u0026rsquo;aide d\u0026rsquo;un appel récursif, puis on fusionne les deux listes triées en une seule liste finale.\nImplémentation # def fusion(L, R): i = j = 0 S = [] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt;= R[j]: S.append(L[i]) i += 1 else: S.append(R[j]) j += 1 while i \u0026lt; len(L): S.append(L[i]) i += 1 while j \u0026lt; len(R): S.append(R[j]) j += 1 return S def tri_fusion(L): if len(L) \u0026lt;= 1: return L mid = len(L)//2 L1 = L[:mid] L2 = L[mid:] L1 = tri_fusion(L1) L2 = tri_fusion(L2) return fusion(L1, L2) Complexité # La complexité $C(n)$ vérifie la relation de récurrence : $C(n) = 2C\\left( \\frac{n}{2} \\right) + O(n)$\nLa complexité est donc $O\\left( n\\log_{2}(n) \\right)$\nTri Rapide # Le tri rapide (ou tri pivot) est un tri récursif qui consiste a choisir un élément pivot p suivant lequel on découpe la liste en deux listes : L1 les éléments inférieurs au pivot, et L2 les éléments supérieurs au pivot, on trie alors chaque partie a l\u0026rsquo;aide d\u0026rsquo;un appel récursif, la liste totale triée est donc : L1 + [p] + L2.\nImplémentation # def quick_sort(L): if len(L) \u0026lt;= 1: return L pivot = L[0] L1=[] L2=[] for i in range(1,len(L)): if L[i] \u0026lt;= p : L1.append(L[i]) if L[i] \u0026gt; p : L2.append(L[i]) return quick_sort(L1) + [p] + quick_sort(L2) Complexité # On note $C(n)$ la complexité de la fonction quick_sort(L), avec n = len(L)\nLa boucle for a une complexité de $O(n)$\nLe coût des appels récursifs quick_sort(L1) et quick_sort(L2) dépend des longueurs des listes L1 et L2:\nAu pire des cas : Le pivot est le plus grand (ou plus petit) élément de la liste, L1 et L2 auront les tailles n-1 et 0, donc : $$C(n) = O(n) + C(n - 1) + C(0)$$ Ce qui donne $$C(n) = O\\left( n^{2} \\right)$$\nAu meilleur des cas : Le pivot est au milieu de la liste, les listes L1 et L2 sont de taille a peu prés n/2, donc : $$C(n) = O(n) + 2C\\left( \\frac{n}{2} \\right)$$ Ce qui donne $$C(n) = O\\left( n\\log(n) \\right)$$\n"},{"id":2,"href":"/fr/docs/spe/03-arbre_binaire/","title":"03 Arbre Binaire","section":"Spe","content":" Arbres binaires # Définitions # En mathématique: Un arbre est un cas spécial de graphe acyclique oriente, ou tous les nœuds sauf la racine ont un unique parent\nEn informatique: C\u0026rsquo;est une structure de données récursive utilisée pour représenter ce type de graphes.\nExemples et terminologie # Un arbre contenant des entiers\nUn arbre est un ensemble de noeuds et d\u0026rsquo;arete reliant ces nœudsChaque noeud a une etiquette : une valeur ou donnee associee au noeud.\nL\u0026rsquo;ordre ou la taille d\u0026rsquo;un arbre est le nombre de noeuds qui le compose.\nLa racine d\u0026rsquo;un arbre est le noeud le plus haut dans l\u0026rsquo;hierarchie de l\u0026rsquo;arbre, c\u0026rsquo;est le noeud \u0026ldquo;de depart\u0026rdquo;.\nTous les noeuds sauf la racine ont un unique pere, c\u0026rsquo;est le noeud directement au-dessus dans l\u0026rsquo;hierarchie.\nLes noeuds ont 0, 1, ou plusieurs fils. Les noeuds sans fils sont appele feuilles de l\u0026rsquo;arbre.\nLe degree d\u0026rsquo;un noeud est le nombre de fils qu\u0026rsquo;il a.\nLa profondeur d\u0026rsquo;un noeud est le nombre d\u0026rsquo;arete necessaire pour aller du noeud a la racine.\nOn s\u0026rsquo;interesse dans ce cours aux arbres binaires, c-a-d, les arbres ayant des noeuds de degree maximum 2.\\\nClasse de complexite\nStructure recursive # On peut definir les arbres binaires de maniere recursive. Un arbre est :\nSoit vide, representee par une liste vide [].\nSoit compose d\u0026rsquo;un noeud racine ayant une valeur $V_{r}$, d\u0026rsquo;un sous-arbre gauche $F_{g}$, et d\u0026rsquo;un sous-arbre droit $F_{d}$. On represente l\u0026rsquo;arbre par la liste [V_r, F_g, F_d].\nExemples # [2, [], []]\n[4, [2, [], []], [8, [1, [], []], []] ]\n[7, [3, [1, [], []], [2, [], []]], [5, [4, [], []], []] ]\nImplementation # def cree_arbre(): return [] def arbre(R, Fg, Fd): return [R, Fg, Fd] def est_vide(A): return A == [] def fils_g(A): if est_vide(A): return None return A[1] def fils_d(A): if est_vide(A): return None return A[2] def racine(A): if est_vide(A): return None return A[0] def est_arbre(A): return est_vide(A) or (isinstance(A, list) and len(A) ==3 and est_arbre(fils_g(A)) and est_arbre(fils_d(A)) def est_feuille(A): return not est_vide(A) and est_vide(fils_g(A)) and est_vide(fils_d(A)) Parcours # On peut parcourir l\u0026rsquo;arbre en privilegiant la largeur, ou la profondeur.\nParcours en profondeur (Depth-First Search): # Prefix : # On parcourt l\u0026rsquo;arbre recursivement suivant l\u0026rsquo;ordre : $V_{r},F_{g},F_{d}$\nInfix : # On parcourt l\u0026rsquo;arbre recursivement suivant l\u0026rsquo;ordre : $F_{g},V_{r},F_{d}$\nPostfix : # On parcourt l\u0026rsquo;arbre recursivement suivant l\u0026rsquo;ordre : $F_{g},F_{d},V_{r}$\nParcours en largeur (Breadth-First Search) # On liste tous les fils du meme niveau de profondeur avant de passer au niveau de profondeur suivant.\nImplementation # def parcours_prefixe(A): if est_vide(A) : return [] return [racine(A)] + parcours_prefixe(fils_g(A)) + \\ parcours_prefixe(fils_d(A)) def parcours_infixe(A): if est_vide(A) : return [] return parcours_infixe(fils_g(A)) + [racine(A)] + \\ parcours_infixe(fils_d(A)) def parcours_postfixe(A): if est_vide(A) : return [] return parcours_postfixe(fils_g(A)) + parcours_postfixe(fils_d(A)) + \\ [racine(A)] def BFS(A): F = [A] while F!=[]: x = F.pop(0) # Traitement sur x print(racine(x)) # Ajout des fils dans la file if not est_vide(fils_g(A)): F.append(fils_g(x)) if not est_vide(fils_d(A)): F.append(fils_d(x)) Arbre Binaire de Becherche (Binary Search Tree) # Un ABR A est un arbre binaire qui verifie les conditions suivantes :\nLes etiquettes du sous-arbre gauche sont inferieures a celle de la racine\nLes etiquettes du sous-arbre droit sont superieures a celle de la racine\nLes sous-arbres gauche et droit sont des ABR (recursivite)\nUn ABR\nOn peut obtenir les etiquettes d\u0026rsquo;un ABR en ordre croissant en faisant un parcours infixe.\nImplementation # def min_abr(ABR): current = ABR while not est_vide(fils_g(current)): current = fils_g(current) return racine(current) def max_abr(ABR): current = ABR while not est_vide(fils_d(current)): current = fils_d(current) return racine(current) def insert(ABR, e): if est_vide(ABR): ABR = [e, [], []] elif e \u0026lt;= racine(ABR) : insert(fils_g(ABR), e) else : insert(fils_d(ABR), e) def search(ABR, e): if est_vide(ABR) : return False if racine(ABR) == e: return True if e \u0026lt; racine(ABR) : return search(fils_g(ABR), e) if e \u0026gt; racine(ABR) : return search(fils_d(ABR), e) def predecessor(ABR, e): if est_vide(fils_g(ABR)) : return None return max_abr(fils_g(ABR)) def successor(ABR, e): if est_vide(fils_d(ABR)) : return None return min_abr(fils_d(ABR)) def remove(ABR, e): # ... Tas # Un Tas T est un arbre binaire qui verifie les conditions suivantes :\nIl est parfait, c\u0026rsquo;est a dire tous les niveaux sauf le dernier doivent être totalement remplis et le dernier niveau est rempli de gauche à droite.\nL\u0026rsquo;etiquette de chaque noeud est superieure ou egale (resp. inferieure ou egale) aux etiquettes de ses fils, on parle de tas max (resp. tas min)\nUn tas\nImplementation # Le tas etant un arbre binaire parfait, on peut l\u0026rsquo;implementer en utilisant une seule liste, ou on met la racine a l\u0026rsquo;indice 0, et pour chaque noeud i on met les fils gauche et droit aux position 2*i+1 et 2*i+2.\nLe tas precedent est donc implemente comme suit : T = [53, 41, 30, 36, 28, 21, 6, 31, 16, 20]\ndef cree_tas(): return [] def insert(T, e): # ... def enleve_racine(T): # ... Tri par tas (Heap sort) # On peut utiliser les tas pour faire le tri: Pour une liste L, on insere successivement les elements de L dans un tas min, puis on enleve la racine successivement jusqu\u0026rsquo;a vider le tas, la racine etant le min a chaque iteration, l\u0026rsquo;ordre des racine enleve sera donc croissant.\ndef tri_par_tas(L): # ... "},{"id":3,"href":"/fr/docs/spe/04-algorithme_glouton/","title":"04 Algorithme Glouton","section":"Spe","content":" Algorithmes Gloutons # Un algorithme glouton est un algorithme qui effectue a chaque instant, le meilleur choix possible sur le moment, sans retour en arrièrearrière ni anticipation des étapes suivantes, dans l\u0026rsquo;objectif d\u0026rsquo;atteindre au final un résultat optimal.\nProblème 1 : Plus grand nombre # On souhaite ecrire le plus grand nombre possible avec un ensemble de chiffres donnes, en n\u0026rsquo;utilisant chaque chiffre qu\u0026rsquo;une seule fois.\nExemples : # Avec les chiffres 2, 3, 8, 6, 4, 7 le plus grand nombre est : 876432\nOn remarque que pour avoir le plus grand nombre possible, on place a chaque ́étape le chiffre le plus grand a gauche (dans la position avec le poids le plus lourd). On fait donc a chaque ́étape le meilleur choix possible; C\u0026rsquo;est un algorithme glouton.\nDonner un programme qui prend plusieurs chiffres, et renvoie le plus grand nombre\ndef plusGrandNombre (L) : return \u0026#39;\u0026#39;.join(map(str, sorted(L, reverse = True))) Problème 2 : Rendu de monnaie # On considère des pièces de monnaie de $1,2,$ et $5$ centimes. On veut trouver la combinaison avec le nombre minimum de pièces pour obtenir exactement $S$ centimes.\nExemple : # Pour $S = 7$, on choisit les pièces $5$ et $2$. Pour $S = 18$ on choisit les pièces $5,5,5,2,1$.\nDonner un programme qui prend un entier prix, et renvoie les pièces a rendre dans l\u0026rsquo;ordre décroissant.\ndef rendu_monnaie(S): R = [] R += [5] * (S//5) S = S % 5 R += [2] * (S//2) S = S % 2 R += [1] * S return R Essayons de résoudre le même probleme pour le systeme de monnaie $4,3,1$. Pour $S = 6$, l\u0026rsquo;algorithme glouton donne $4,1,1$. Alors que la solution optimale est $3,3$.\ntitle: \u0026ldquo;Attention :\u0026rdquo;, [ Les algorithmes glouton n\u0026rsquo;arrivent pas toujours a trouver la solution globalement optimale car ils n\u0026rsquo;essayent pas toutes les combinaisons possibles. Ils peuvent s\u0026rsquo;engager trop tˆot sur certains choix, les empˆechant de trouver la meilleure solution globale par la suite ]\nProbleme 3 : Fractions Égyptiennes # Une fraction égyptienne est une fraction de numerateur égal a 1. On souhaite ́ecrire une fraction $$\\frac{a}{b}$$, comme somme de fractions ́egyptiennes avec des denominateurs tous différents.\nExemple : # La fraction $\\frac{2}{3} = \\frac{1}{2} + \\frac{1}{6}$\nLa fraction $\\frac{2}{5} = \\frac{1}{3} + \\frac{1}{15}$\nLa fonction prend en paramètres $a$ et $b$ et renvoie la liste des dénominateurs des fractions qui composent la somme.\ndef fractions_egy(a, b): i = 2 R = [] while a \u0026gt; 0: if a*i - b \u0026gt;= 0 : a, b = a*i - b, b*i R.append(i) i += 1 return R Problème 4 : Sélection d\u0026rsquo;activités # On se donne un ensemble d\u0026rsquo;activités $a_{i}$ qui doivent chacune se dérouler pendant un intervalle de temps $\\lbrack d_{i},f_{i}\\lbrack$. On veut determiner le maximum d\u0026rsquo;activites qu\u0026rsquo;une personne peut faire, qui se déroulent pendant des intervalles de temps disjoints (une personne ne peut faire qu\u0026rsquo;une activite a la fois).\nOn represente chaque activite par une liste de trois elements : [i, d, f], l\u0026rsquo;indice de l\u0026rsquo;activite i, l\u0026rsquo;heure de debut d, et l\u0026rsquo;heure de fin f.\nLa fonctions prend en parametre une liste d\u0026rsquo;activite A, et renvoie la liste des indices i des activites choisies.\ndef select_activities(A): L = sorted(A, key = lambda x: x[2]) S = [L[0][0]] f = L[0][2] for i in range(1, len(L)) : if L[i][1] \u0026gt;= f : S.append(L[i][0]) f = L[i][2] return S "},{"id":4,"href":"/fr/docs/spe/05-programation_dynamique/","title":"05 Programation Dynamique","section":"Spe","content":" Programation Dynamique # On considere le programme python suivant, qui permet de calculer le nieme terme de la suite fibonacci :\ndef fibo(n): if (n == 0 or n == 1): return 1 return fibo(n-1) + fibo(n-2) Pour n = 4 on remarque l\u0026rsquo;arbre des appels suivant :\nArbre d’appels recursifs.\nCet algorithme recursif est de complexite $O\\left( \\varphi^{n} \\right)$. Ceci est du au fait que cet algorithme resoud les memes sous-problemes plusieurs fois (fibo(2) par exemple, qui est appele 2 fois).\nOn peut donc ameliorer la solution en gardant les resultats deja calcules en memo. C\u0026rsquo;est la technique de Memoisation ou programation dynamique top-down.\nfibo_cache = {} def fibo_memo(n): if n in fibo_cache : return fibo_cache[n] if n == 0 or n == 1 : fibo_cache[n] = 1 return 1 fibo_cache[n] = fibo_memo(n-1) + fibo_memo(n-2) return fibo_cache[n] Une deuxieme technique est de calculer les resultats par ordre croissant des sous-problemes, c\u0026rsquo;est l\u0026rsquo;approche bottom-up utilise dans l\u0026rsquo;algorithme iterative.\ndef fibo_iter(n): a, b = 1,1 for i in range(n): a, b = b, a+b return a ** Caracterisation :**\nOn utilise la programmation dynamique pour resoudre les problemes qui exhibent les 2 proprietes suivantes :\nChevauchement des sous-problemes\nSous-structure optimale\nProbleme 1 : Longest Common Subsequence # Etant donne deux listes X et Y, determiner la longueur de la sous-sequence la plus longue.\nExemple :\nX = [1, 5, 3, 7, 2, 8, 6, 4]\nY = [1, 3, 1, 2, 8, 5, 4]\nLa plus longue sous-sequence est : [1, 3, 2, 8, 4], qui est de longueur 5.\nmemo = [ [-1 for i in range(1000) ] for i in range(1000) ] def lcs(X, Y): if memo[len(X)][len(Y)] != -1 : return memo[len(X)][len(Y)] if X == [] or Y == []: memo[len(X)][len(Y)] = 0 return 0 if X[0] == Y[0]: s = 1 + lcs (X[1:], Y[1:]) memo[len(X)][len(Y)] = s return s s = max ( lcs{X[1:], Y), lcs(X, Y[1:]) ) memo[len(X)][len(Y)] = s return s Probleme 2 : Distance Levenshtein # Etant donne deux chaines de caracteres s1 et s2, on veut calculer le nombre minimal d\u0026rsquo;operations necessaires pour transformer s1 en s2, sachant que les operations possibles sont :\nAjout d\u0026rsquo;un caractere\nSuppression d\u0026rsquo;un caractere\nModification d\u0026rsquo;un caractere\nExemple :\ns1 = \u0026quot;m o r o c c o\u0026quot;\ns2 = \u0026quot;m o n a c o\u0026quot;\nDans ce cas, la distance de Levenshtein est 3; on va modifier \u0026lsquo;r\u0026quot; et \u0026lsquo;o\u0026rsquo;, et supprimer \u0026lsquo;c\u0026rsquo;.\nmemo = {} def lev(X, Y): if (len(X), len(Y)) in memo : return memo[(len(X), len(Y))] if X == \u0026#39;\u0026#39; or Y == \u0026#39;\u0026#39;: memo[(len(X), len(Y))] = len(X) + len(Y) return len(X) + len(Y) if X[0] == Y[0]: s = lev (X[1:], Y[1:]) memo[(len(X), len(Y))] = s return s s = 1 + min ( lev(X[1:], Y), lev(X, Y[1:]), lev(X[1:], Y[1:]) ) memo[(len(X), len(Y))] = s return s Probleme 3 : Rod cutting # Une entreprise souhaite vendre une barre metalique de taille l. etant donne une liste prix qui associe a chaque longeur i le prix du marche prix[i] d\u0026rsquo;une barre metalique de taille i, Quel est le decoupage optimale pour maximiser le gain.\nmemo = {} def rod_cutting(prix, l): if l in memo: return memo[l] if l == 0: memo[0] = 0 return 0 L = [] for i in range(1, min(l+1, len(prix)): L.append(prix[i] + rod_cutting(l-i)) s = max(L) memo[l] = s return s Probleme 4 : Sac a dos (Knapsack) # Fractional Knapsack\ndef knapsack(V, volumes, prix): data = [ [volumes[i], prix[i]] for i in range(len(prix)) ] data.sort(key=lambda x : x[1], reverse = True) s = 0 i = 0 while V \u0026gt; 0: if data[i][0] \u0026gt;= V : s += data[i][1] * V return s s += data[i][1] * data[i][0] V -= data[i][0] i+=1 return s Unbound Knapsack\nmemo = {} def knapsack(data, V): if V in memo: return memo[V] L = [] for i in range(len(data)): if data[i][0] \u0026lt;= V : L.append( data[i][1] + knapsack(data, V-data[i][0]) ) if L == []: memo[0] = 0 return 0 memo[V] = max(L) return memo[V] 0-1 Knapsack\nProbleme 5 : Longest Increasing Subsequence (LIS) # memo = {} def LIS(L, v=0): if (len(L), v) in memo : return memo[(len(L), v)] if L == [] : memo [(0, v)] = 0 return 0 if L[0] \u0026gt; v: a = LIS(L[1:], L[0]) else : a = 0 s = max(a, LIS(L[1:], v)) memo [(len(L), v)] = s return s Probleme 6 : Subset sum # memo = {} def subset_sum(L, S): if (len(L), S) in memo : return memo[(len(L), S)] if S == 0 : memo[(len(L), S)] = True return True if L == [] and S != 0: memo[(len(L), S)] = False return False if L[0] \u0026lt;= S : r = subset_sum(L[1:], S-L[0]) or subset_sum(L[1:], S) else : r = subset_sum(L[1:], S) memo[(len(L), S)] = r return r ]\nProbleme 7 : Lattice path # Probleme 8 : Commercant voyageur (Traveling Sales-Person) # "},{"id":5,"href":"/fr/docs/spe/06-les_graphes/","title":"06 Les Graphes","section":"Spe","content":" Les graphes # Un graphe est un ensemble de sommets (noeuds) reliee par des aretes (arcs)\nGraphe\n$G = (V,E)$, avec $V$ l\u0026rsquo;ensemble de noeuds, $E$ l\u0026rsquo;ensemble d\u0026rsquo;aretes.\nNotions de bases # L\u0026rsquo;Ordre d\u0026rsquo;un graphe: c\u0026rsquo;est le nombre de noeuds du graphe : $\\text{card}(V)$\nGraphe oriente / non-oriente\nGraphe pondere / non-pondere\nDegree d\u0026rsquo;un noeud, degree entrant, degree sortant\nChaine, cycle\nChaine eulerienne\nChaine hamiltonienne\nImplementation python # En python, on peut representer un graph de deux manieres :\nListe d\u0026rsquo;adjacence: c\u0026rsquo;est une liste qui pour chaque noeud i donne la liste des noeuds adjacent a i L = [[1, 2], [0, 2, 4], [0, 1, 3], [2, 4], [1, 3, 5], [4] ] Matrice d\u0026rsquo;adjacence: c\u0026rsquo;est une liste M a deux dimmensions avec M[i][j] = 1 si i et j sont liee, 0 sinon. M = [[0, 1, 1, 0, 0, 0], [1, 0, 1, 0, 1, 0], [1, 1, 0, 1, 0, 0], [0, 0, 1, 0, 1, 0], [0, 1, 0, 1, 0, 1], [0, 0, 0, 0, 1, 0] ] DFS # def DFS(G, visite, x): visite[x] = True print(x) for i in range(len(G)): if G[x][i] == 1 and not visite[i] : DFS(G, visite, i) BFS # def BFS(G, x): F = [x] while F!=[]: for i in range(len(G)): F Plus court chemin : Dijkstra # "},{"id":6,"href":"/fr/docs/spe/07-sql/","title":"07 SQL","section":"Spe","content":" Introduction # Les bases de donnes SQL suivent le modele relationel, qui permet d\u0026rsquo;organiser les donnes dans plusieurs tables composes de colonnes\n"},{"id":7,"href":"/fr/docs/sup/00-system_info/","title":"00 System Info","section":"Sup","content":" Système Informatique # Un système informatique est un ensemble organisé de ressources matérielles et logicielles destiné au traitement automatique de l\u0026rsquo;information.\nExemples: # Ordinateur;\nTablette;\nSmart-Phone;\nCalculatrice programmable.\nLes constituants de base # La structure de base d\u0026rsquo;un ordinateur peut se résumer sur les composantes suivantes:\nLe processeur;\nLa mémoire centrale;\nLes unités de stockage;\nLes périphériques.\nUne mémoire est tout organe capable de conserver des informations de de les restituer à la demande. Elle est caractérisée par sa capacité qui est le nombre des caractères qu\u0026rsquo;on peut stocker dans la mémoire. L\u0026rsquo;unité de mesure de cette capacité est Octet. La mémoire centrale est découpée en octets, chacun de ces octets est identifié par un numéro séquentiel appelé adresse mémoire. La mémoire centrale est composée de deux types de mémoires : Mémoire vive (RAM : Random Access Memory) Mémoire morte (ROM : Read Only Memory).\nLe microprocesseur # Le microprocesseur est le centre de calcul et de contrôle, Il constitue le cerveau de l\u0026rsquo;ordinateur. Le microprocesseur est composé de deux organes:\nUnité arithmétique et logique (UAL): c\u0026rsquo;est l\u0026rsquo;organe qui permet d\u0026rsquo;effectuer les opérations mathématiques (addition, division\u0026hellip;)\nUnité de commande: Celle là permet de de générer tous les ordres nécessaires pour le fonctionnement de l\u0026rsquo;ordinateur.\nRemarque: Un microprocesseur est caractérisé par:\nSa marque: Intel, Cyrix, Motorola.\nSa fréquence: elle détermine le nombre des opérations que le microprocesseur\npeut effectuer en une seconde, elle est mesurée en (Hz).\nUnité de stockage # Les unités de stockage sont des mémoires auxiliaires (mémoires de masse) qui conservent les données, tel que: Les bandes, les disquettes, les disques durs, mémoire flash, les CD (Compact Disk) les DVD (Digital Versatile Disk)\u0026hellip;\nLes Périphériques # Il existe trois types de périphériques:\nLes périphériques d\u0026rsquo;entrée: clavier, souris, scanner..\nLes périphériques de sortie: moniteur, imprimante..\nLes périphériques d\u0026rsquo;entrée-sortie: lecteur de disquette, graveur, carte réseau..\nSytème d\u0026rsquo;exploitation # Système d\u0026rsquo;exploitation ou OS (Operating System) c\u0026rsquo;est un programme qui gère les ressources matérielles et logicielles de l\u0026rsquo;ordinateur à la demande d\u0026rsquo;un programme ou de l\u0026rsquo;utilisateur, il est chargé de contrôler et d\u0026rsquo;organiser le fonctionnement de l\u0026rsquo;ordinateur.\nExemples # Microsoft Windows (pour les PC): Windows XP, Vista, 7, 8, 10, 11.\nApple Mac OS (pour les ordinateurs Apple): Tigger, MacOS X.\nUnix (pour les serveurs): Ubuntu, Mandriva, RedHat,\u0026hellip;\nLes systèmes embarqués (pour les téléphones, télévisions, voitures\u0026hellip;): Android de Google, iOS d\u0026rsquo;Apple, Windows Phone de Microsoft\u0026hellip;\nUn système d\u0026rsquo;exploitation est chargé de plusieurs fonctions dont les principales sont les suivantes:\nFournir une interface de communication entre l\u0026rsquo;utilisateur et l\u0026rsquo;ordinateur.\nLa gestion des fichiers et dossiers.\nGérer, partager et optimiser l\u0026rsquo;utilisation des ressources matérielles et logicielles de l\u0026rsquo;ordinateur.\nEnvironnement de développement intégré (IDE) # un IDE est un logiciel regroupant un ensemble d\u0026rsquo;outils nécessaires au développement logiciel dans un (ou plusieurs) language(s) de programmation.\nExemples d\u0026rsquo;IDE:\nMicrosoft .NET pour C, C++\nNetBeans pour Java\nVisual Studio 10\nEclipse\nLes composantes d\u0026rsquo;un IDE inclues au minimum dans un IDE:\nUn éditeur de texte spécialisé (avec coloration syntaxique, indentation automatique, complétion automatique, \u0026hellip;)\nUn compilateur (ou au moins l\u0026rsquo;intégration d\u0026rsquo;un compilateur existant)\nDes outils de conception (test, recherche d\u0026rsquo;erreurs)\nUn générateur de documentation\n"},{"id":8,"href":"/fr/docs/sup/01-codage/","title":"01 Codage","section":"Sup","content":" Introduction # Représentation des données dans la mémoire # Quelle que soit la nature de l\u0026rsquo;information (image, son, vidéo, texte, \u0026hellip;) traitée par un ordinateur, elle est toujours sous la forme d\u0026rsquo;un ensemble de nombres écrits en binaire (0 et 1).\\\nSysteme de numeration binaire # On appelle base un entier B strictement positif. Tout entier n peut alors s\u0026rsquo;écrire de façon unique comme ci-dessous: $$n = \\sum_{i = 0}^{k}n_{i}B^{i} = n_{k}B^{k} + n_{k - 1}B^{k - 1} + \\ldots + n_{1}B + n_{0}$$ $n$ s\u0026rsquo;écrit donc: $$n = \\left( n_{k}n_{k - 1}\\ldots n_{0} \\right){B}\\quad\\text{ avec }\\quad n{i} \\in ⟦0,B⟦$$ On compte habituellement en base 10 mais un ordinateur compte en base 2 car les circuits utilisés peuvent avoir deux états auxquels correspondent deux chiffres 0 et 1. On parle de numérotation binaire. Les éléments 0 et 1 sont appelés BIT (Binary Digit), Un groupe de huit bits est nommé Octet (attention! Octet se dit Byte en anglais.)\nLes systèmes informatiques travaillent sur des longueurs fixes de bits appelées MOT. Un MOT est la plus grande série de bits qu\u0026rsquo;un ordinateur puisse traiter en une seule opération. Par exemple le microprocesseur intel i5 appartient a la famille x86_64 qui utilise des mots de 64 bits.\nReprésentation des entiers naturels en binaire # Pour obtenir l\u0026rsquo;expression binaire d\u0026rsquo;un nombre exprimé en décimal, on divise le nombre par 2 puis on divise successivement les quotients obtenus par 2 jusqu\u0026rsquo;à ce que le quotient final obtenu soit égal à 0. Les restes obtenus forment la representation voulu.\nExemple: # Pour $n = 77$, on effectue les divisions suivantes:\nDivisions successives du par 2\nLa representation binaire de 77 est donc $n = (1001101)_{2}$ Avec une taille de mot de 8 bits, on peut representer les entiers $⟦0,255⟧$\nRepresentation des entiers relatifs # Representation par signe et valeur absolue sur 8 bits # On represente les nombres positifs comme vu precedement pour les nombres naturels sur 7 bits, et on rajoute 0 comme bit de poids le plus fort.\nPour les nombres negatifs, le bit de poids le plus fort est un 1\nExemple: # $77 = (01001101)_{2}$\n$- 77 = (11001101)_{2}$\nRemarques:\\\nAvec une taille de mot de 8 bits, on peut representer les entiers $⟦ - 127,127⟧$\nLe 0 est represente deux fois: $+ 0 = (00000000){2}$ et $- 0 = (10000000){2}$\nRepresentation par Complement a 2 sur 8 bits # On represente les nombres positifs comme vu precedement pour les nombres naturels sur 7 bits. On aura donc toujours un 0 comme bit de poids fort.\nPour les nombres negatifs, on ecrit leur valeur absolue en binaire naturel, puis on applique la fonction appelee complement a 2, qui consiste a faire le complement a 1 puis d\u0026rsquo;ajouter 1.\nExemple: # Pour representer -77 on commence par la representation de 77:\n$$77 = (01001101){2}$$ On applique le complement a 1 (le NON binaire), c\u0026rsquo;est a dire on inverse les 0 en 1 et les 1 en 0. On obtient: $$(10110010){2}$$ Puis on rajoute 1 et on obtient la representation de -77 par complement a 2 sur 8 bits : $$- 77 = (10110011)_{2}$$ Remarques:\\\nAvec une taille de mot de 8 bits, on peut representer les entiers $⟦ - 128,127⟧$\n$C_{2}\\left( C_{2}(n) \\right) = n$\n$C_{2}(n) + n = 0$\nRepresentation des nombres a virgule # Format virgule fixe # On complete la definition precedente par les puissance de 2 negatives: $$n = \\sum_{i = - k}^{k}n_{i}B^{i} = n_{k}B^{k} + n_{k - 1}B^{k - 1} + \\ldots + n_{1}B + n_{0} + n_{- 1}B^{- 1} + \\ldots + n_{- k\u0026rsquo;}B^{- k\u0026rsquo;}$$ $$n = \\left( n_{k}n_{k - 1}\\ldots n_{0},n_{- 1}\\ldots n_{- k\u0026rsquo;} \\right){B}\\quad\\text{ avec }\\quad n{i} \\in ⟦0,B⟦$$ On represente la partie entiere comme pour les entiers naturels. Pour la partie fractionnaire, on effectue des multiplications successive par deux, en prenant les parties entieres a chaque fois.\nExemple: # Pour representer $13,375$, on represente 13 par $(1101){2}$, puis on represente la partie fractionnaire comme suit: $$0,375 \\times 2 = 0,75$$ $$0,75 \\times 2 = 1,5$$ $$0,5 \\times 2 = 1,0$$ On va lire les parties entieres des resultats de haut en bas $(0,011)$\nDonc $$13,375 = (1101,011){2}$$\nFormat virgule flottante # La norme IEEE 754 definit la maniere de representer les nombres reels a partir de leur notation scientifique : $$n = \\pm m \\times B^{e}\\text{ avec }1 \\leq m \u0026lt; B$$ En binaire $1 \\leq m \u0026lt; 2$. On note $m\u0026rsquo;$ la partie fractionnaire de $m$ donc: $$m = (1,m\u0026rsquo;){2}$$ Ce qui donne : $$n = \\pm (1,m\u0026rsquo;){2} \\times 2^{e}$$ La norme propose deux format:\nSimple precision qui s\u0026rsquo;ecrit sur 32 bits.\nDouble precision, sur 64 bits.\nEn simple precision le nombre n est represente par trois composantes:\n1 bit de signe (0 si positif, 1 si negatif)\n8 bits pour l\u0026rsquo;exposant modifie: $e\u0026rsquo; = e + 127$\n23 bits pour la mantisse (la partie fractionnaire, $m\u0026rsquo;$)\n[S]{.box} [e]{.box} [e]{.box} [e]{.box} [e]{.box} [e]{.box} [e]{.box} [e]{.box} [e]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box} [m]{.box}\nRemarques:\\\nL\u0026rsquo;exposant 00000000 et l\u0026rsquo;exposant 11111111 sont interdit.\nOn rajoute 127 a l\u0026rsquo;exposant pour pouvoir representer les exposants de $⟦ - 127,128⟧$\nExemple: # Pour coder le nombre $n = 113,25$ :\nn est positif, donc le bit de signe S = 0 $$113 = (01110001){2}\\quad\\text{ et }\\quad 0,25 = (0,01){2}$$ Donc $$n = (01110001,01)_{2}$$ $$n = 1,11000101 \\times 2^{6}$$ $$m\u0026rsquo; = 11000101\\quad\\text{ et }\\quad e\u0026rsquo; = 6 + 127 = 133 = (10000101)$$ d\u0026rsquo;ou la representation de n : $$0:10000101:11000101:000000000000000$$\nCodage des caractères # L\u0026rsquo;ASCII est une norme décrivant une table d\u0026rsquo;encodage sur 7 bits de 128 caracteres pour les systèmes informatiques. Elle est apparue dans les années 1960 et est notamment utilisée pour le codage des 95 caractères imprimables d\u0026rsquo;une machine à écrire\nL\u0026rsquo;ASCII définit 128 caractères numérotés de 0 à 127 et codés en binaire de 0000000 à 1111111. Sept bits suffisent donc. Toutefois, les ordinateurs travaillant presque tous sur un multiple de huit bits (un octet) depuis les années 1970, chaque caractère d\u0026rsquo;un texte en ASCII est souvent stocké dans un octet dont le 8e bit est 0.\nTableau ASCII\n"},{"id":9,"href":"/fr/docs/sup/02-intro_python/","title":"02 Intro Python","section":"Sup","content":" Introduction # Définitions # Algorithme : # C\u0026rsquo;est une suite finie d\u0026rsquo;opérations ou d\u0026rsquo;instructions permettant de résoudre des problèmes, par exemple : une recette de cuisine, un manuel d\u0026rsquo;installation, etc.\nProgramme : # Un programme est un algorithme écrit dans un langage de programmation, destine à être exécuté par une machine, pour résoudre un problème donne.\nNous utiliserons le langage Python.\nNotion de variable # Définitions # Une variable est une case mémoire qui a un nom (un identificateur) et contient une valeur et qui est utilisé au cours d\u0026rsquo;un programme.\nOn l\u0026rsquo;appelle variable parce que sa valeur varie au cours de l\u0026rsquo;exécution du programme.\nExemple # En python, on crée une variable en lui affectant une valeur :\na = 3 On définit une variable nomme a et on lui affecte la valeur 3\nshowybox( title: \u0026ldquo;Attention :\u0026rdquo;, color: \u0026ldquo;red\u0026rdquo;, radius: 2pt, width: auto, )[ L\u0026rsquo;opérateur = n\u0026rsquo;a pas la même signification qu\u0026rsquo;en mathématique.\nIci, il permet d\u0026rsquo;affecter une valeur à une variable, et il n\u0026rsquo;est pas commutatif.\nOn peut l\u0026rsquo;imaginer comme suit : $a \\leftarrow 3$ ]\nIdentificateur de variable # L\u0026rsquo;identificateur d\u0026rsquo;une variable peut contenir les lettres minuscules ou majuscules A-Z et a-z, ainsi que les chiffres 0-9, et le caractère _. Il ne peut pas contenir d\u0026rsquo;espace, et ne doit pas commencer par un chiffre.\nExemple # ma_variable, Variable1, compteur_2 sont des noms valides.\nma-variable, 3eme_conpteur ne sont pas des noms valides.\nTypes de variables # Les valeurs contenues par les variables peuvent être de différents types :\nEntier : en anglais \u0026ldquo;integer\u0026rdquo; ou int\nRéel : \u0026ldquo;floating point\u0026rdquo; ou float\nLa virgule est toujours notée . en python, e.g a = 32.25\nChaine de caractères : \u0026ldquo;string\u0026rdquo; ou str\nUne chaine est toujours entourée par des simples quotes ' ou \u0026quot;\u0026quot;\nBooléen : bool qui peut être soit True ou False\nLes commentaires # On peut ajouter dans le code python des commentaires qui ne seront pas exécutés par python, et qui servent à décrire ou expliquer une partie du code. Les commentaires commencent par #\nExemple # # Ceci est mon premier programme Python ! var1 = 5 # ici je declare une variable var2 = 3.25 # une autre variable. Entrée, sortie # Pour afficher le contenu d\u0026rsquo;une variable a l\u0026rsquo;utilisateur, on utilise la fonction print() Exemple # a = 3 mon_nom = \u0026#34;Ahmed\u0026#34; print(a) # Cette instruction affiche 3 print(mon_nom) # Affiche Ahmed Pour lire ce que l\u0026rsquo;utilisateur écrit, on utilise la fonction input() Exemple # nom = input(\u0026#34;Entrez votre nom : \u0026#34;) print(\u0026#34;Bonjour, \u0026#34; + nom) Lors de l\u0026rsquo;exécution de ce programme, l\u0026rsquo;utilisateur va entrer son nom qui va être enregistre dans la variable nom sous forme de chaine de caractères qu\u0026rsquo;on affiche par la suite.\nChangement de type d\u0026rsquo;une variable # On peut obtenir le type d\u0026rsquo;une variable en utilisant la fonction type()\nExemple # a = 12 b = 3.25 c = \u0026#34;hello\u0026#34; print(type(a)) # Affiche int print(type(b)) # Affiche float print(type(c)) # Affiche str On peut transformer une chaine de caracteres comme \u0026quot;15\u0026quot; en un entier (type int) 15 a l\u0026rsquo;aide de la fonction int()\nExemple # a = \u0026#34;5\u0026#34; print(type(a)) # str x = int(a) print(type(x)) # int La fonction int est notament utilisee pour obtenir un entier de chez l\u0026rsquo;utilisateur comme suit :\nx = int(input(\u0026#34;Entrez un nombre\u0026#34;)) Opérations arithmétiques et logiques # On peut réaliser différentes opérations sur les variables.\nPour les nombres (type int ou float) :\nAddition +\nSoustraction -\nMultiplication *\nPuissance **\nDivision /\nDivision entière // : Donne le quotient de la division euclidienne.\nModulo % : Donne le reste de la division euclidienne.\nExemples # n = 3 * 5 m = n - 10 p = m ** 2 print(17/5) print( 8 / 3 ) # les espaces ne font aucune difference print( 8 % 3 ) # affiche 2 a = 7 b = 3 c = a % b # On peut operer sur des variables. Pour les chaines de caractères (type str) :\nConcaténation +\nConcaténation multiple *\nExemple # a = \u0026#34;hello \u0026#34; b = \u0026#34;World\u0026#34; print(a + b) #Affiche \u0026#34;hello World\u0026#34; print(3*a) #Affiche \u0026#34;hello hello hello \u0026#34; Pour les booléens (type bool) :\nNégation not\n\u0026ldquo;ou\u0026rdquo; logique or\n\u0026ldquo;et\u0026rdquo; logique and\nExemple # var1 = True var2 = False var3 = var1 and not var2 print(var1 or var2) Opérateurs de comparaison # Les opérateurs suivants permettent de comparer deux éléments, leur résultat et un booléen (True ou False)\nPour les nombres (type int ou float) :\nÉgalité ==\nDifférent !=\nInférieur a \u0026lt;\nInférieur ou égale à \u0026lt;=\nSupérieur a \u0026gt;\nSupérieur ou égale à \u0026gt;=\nExemple # a = 3 b = 5 c = a \u0026lt;= b print(c) # Affichera True print(b + 4 \u0026gt; 10) # Affichera False La structure conditionnelle # Pour exécuter différentes instructions suivant la validité d\u0026rsquo;une condition, on utilise la structure \u0026ldquo;if-else\u0026rdquo;\nExemple # if condition : # La variable condition est de type bool print(\u0026#34;A\u0026#34;) # Attention à l\u0026#39;indentation else : print(\u0026#34;B\u0026#34;) En general, on utilise les operateurs de comparaison comme condition puisqu\u0026rsquo;ils renvoient un bool\nif x \u0026gt;= 0 : print(x) else : print(-x) On peut avoir plusieurs conditions en utilisant la forme \u0026ldquo;if-elif-else\u0026rdquo;\nif x\u0026gt;=0 and x\u0026lt;10 : print(\u0026#34;A\u0026#34;) elif x\u0026gt;=10 and x\u0026lt;20 : print(\u0026#34;B\u0026#34;) elif x \u0026lt; 0 : print(\u0026#34;C\u0026#34;) else : print(\u0026#34;D\u0026#34;) Les structures itératives # Les structures itératives permetent de répéter un bloc d\u0026rsquo;instructions plusieurs fois.\nLa structure while La structure while répète les instructions tant qu\u0026rsquo;une condition est vrai.\nSyntaxe # while condition : print(\u0026#34;A\u0026#34;) Exemples # x = 10 while x \u0026gt; 0 : print(\u0026#34;A\u0026#34;) x = x - 1 x = 0 while x \u0026lt; 10 : print(x) x += 1 La structure for La structure for est déterministe : elle répète les instructions un nombre déterminé de fois.\nSyntaxe # for variable in collection : print(variable) Exemples # for i in range(10) : print(i) for i in range(10) : if i % 2 == 0: print(i) S = 0 for i in range(0, 101) : S += i print(S) La fonction range() peut être appelé avec 1, 2, ou 3 arguments :\nrange(5) donnera les nombres : 0, 1, 2, 3, 4\nrange(2, 7) donnera les nombres : 2, 3, 4, 5, 6\nrange(1, 12, 2) donnera les nombres : 1, 3, 5, 7, 9, 11\nLe mot cle continue Le mot cle continue permet de sauter le reste de la boucle et passer directement a la prochaine iteration.\nExemple # for i in range(10): if i%2 == 0: continue print(i) Pour chaque i pair, le mot cle continue va sauter le reste des instructions dans la boucle (notament le print), et va continuer d\u0026rsquo;iterer, c\u0026rsquo;est a dire passer a la prochaine iteration. La boucle n\u0026rsquo;affichera alors que les nombres impairs.\nLe mot cle break Le mot cle break va immediatement arreter la boucle sans executer les prochaines iterations.\nExemple # for i in range(10): if i == 5: break print(i) print(\u0026#34;fin\u0026#34;) Pour i de 0 a 4, la boucle va afficher le nombre i. Pour i=5, le mot cle break va sauter les instructions de la boucle (notament le print), et va sortir de la boucle, et afficher fin.\nLa boucle affichera :\n0 1 2 3 4 fin\nLe mot cle pass Le mot cle pass est une instruction qui ne fait rien.\n"},{"id":10,"href":"/fr/docs/sup/03-les_fonctions/","title":"03 Les Fonctions","section":"Sup","content":" Introduction # Pour mieux structurer nos programmes et les rendres reutilisables, on les regroupe dans des unites appelee \u0026ldquo;fonctions\u0026rdquo;.\nUne fonction est donc un \u0026ldquo;bout de code\u0026rdquo;, un ensemble d\u0026rsquo;instructions qui est executee et renvoie un resultat a partir des donnes d\u0026rsquo;entree :\nSchema d’une fonction python\nSyntaxe # Pour creer une fonction, on utilise la syntaxe suivante:\ndef ma_fonction(x, y, z): # Bloc d\u0026#39;instructions def est un mot cle qui permet de commencer la definition d\u0026rsquo;une fonciton.\nLe nom d\u0026rsquo;une fonction obeit aux memes regles que les noms de variables.\nLes parametres de la fonctions sont mis entre parenthese\nExemple # def double(x): print(x * 2) Le code ci-dessus definit une fonction qui prend une variable x et qui affiche la valeur x * 2\ntitle : [ Attention :], [ L\u0026rsquo;execution de ce code ne va rien faire, parcequ\u0026rsquo;il s\u0026rsquo;agit uniquement d\u0026rsquo;une definition de la fonction. Pour l\u0026rsquo;executer il faut appeler la fonction. ]\nL\u0026rsquo;appel de la fonction se fait comme suit :\ndouble(3) Ce code fait appel a la fonction double avec le parametre x = 3. La fonction va s\u0026rsquo;executer et afficher 6.\nEn generale on evite d\u0026rsquo;ecrire des fonctions qui affiche leur resultat, et on opte plutot pour des fonctions qui renvoie le resultat a l\u0026rsquo;aide du mot cle return.\nExemple # def cube(x): return x * x L\u0026rsquo;appel a cette fonction va renvoyer le resultat x * x On peut alors recuperer le resultat en l\u0026rsquo;affectant a une variable comme suit :\ny = cube(3) La fonction va etre executee pour la valeur x=3, va calculer le resultat et le renvoyer, pour qu\u0026rsquo;il soit affectee a la variable y.\nProcedure # Lorsequ\u0026rsquo;une fonction ne contient pas le mot cle return, on dit qu\u0026rsquo;elle ne renvoie rien. En realite, python va plutot renvoyer une valeur speciale appelee None.\nOn appele les fonctions qui ne renvoient rien des procedures.\nParametre facultatif # On peut faire en sorte d\u0026rsquo;avoir une fonction qui peut etre appelee avec ou sans un parametre. Ce parametre est alors facultatif, et on doit definir la valeur par defaut de ce parametre.\nExemple # def ma_fonction(x, y=10): print(x, y) On peut appelee cette fonction en lui donnant 1 ou 2 parametre :\nma_fonction(5, 6) # affiche \u0026#34;5 6\u0026#34; ma_fonction(3) # affiche \u0026#34;3 10\u0026#34; Variable locale vs variable globale # Considerons le code suivant:\ndef test(): a = 6 a = 5 test() print(a) Ce code est contre-intuitive, contrairement a ce qu\u0026rsquo;on peut croire, il affiche la valeur 5\nVoici en detail ce qui se passe :\nLes lignes 1 et 2 ne vont rien faire puisqu\u0026rsquo;il s\u0026rsquo;agit d\u0026rsquo;une definition de fonction.\nLa ligne 4 declare une variable appelee a ayant la valeur 5\nLa ligne 5 fait appel a la fonction test, l\u0026rsquo;interpreteur va alors executer la ligne 2.\nLa ligne 2 declare une nouvelle variable appelee a ayant pour valeur 6\nMeme si les deux variables ont le meme nom, la premiere est globale, c\u0026rsquo;est-a-dire accessible depuis n\u0026rsquo;importe ou dans le code, alors que la deuxieme est locale a la fonction test\nLa fonction etant executee, on revient a la ligne 6\nLa ligne 6 va afficher la variable a, puisqu\u0026rsquo;on est a l\u0026rsquo;exterieur de la fonction, la variable locale a la fonction test n\u0026rsquo;est plus accessible, on va donc afficher la variable a globale, qui contient toujours la valeur 5\nFonction annonyme # Python permet de manipuler les fonctions comme on manipule des variables, on peut donc envoyer une fonction en parametre a une autre fonction, et on peut creer des fonction annonyme, qui n\u0026rsquo;ont pas de nom.\nSyntaxe # f = lambda x : x * x g = lambda y : y + 2 h = lambda x : g(f(x)) "},{"id":11,"href":"/fr/docs/sup/04-les_listes/","title":"04 Les Listes","section":"Sup","content":" Introduction # Une liste est un ensemble d\u0026rsquo;objets mis dans un ordre précis. Elles sont définies entre crochets et les éléments sont séparés par une virgule.\nSyntaxe # L\u0026rsquo;identificateur (le nom) d\u0026rsquo;une liste suit les memes regles que les identificateurs de variables. On definit une liste vide comme suit:\nma_liste = [] Sinon, une liste peut comporter des elements quelconques :\nL = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] On peut creer une liste contenant n fois le meme objet :\nL = [0] * 4 # Donnera la liste [0, 0, 0, 0] On peut utiliser les operateurs + pour la concatenation de deux listes, et * pour la repetition d\u0026rsquo;une liste.\nT = [1, 2] * 2 # Donnera [1, 2, 1, 2] S = [\u0026#39;a\u0026#39;, 10] + [1] * 3 # Donnera [\u0026#39;a\u0026#39;, 10, 1, 1, 1] Pour la suite du cours, on considere la liste L suivante :\n# 0 1 2 3 4 5 \u0026lt;--- l\u0026#39;indice de chaque element L = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] Les elements de la liste sont indexes a partir de 0, Pour acceder aux elements de la liste:\nprint(L[3]) # Affichera True print(L[0]) # Affichera 2 print(L[1]) # Affichera hello Attention: le premier élément correspond à l\u0026rsquo;indice 0\nModification d\u0026rsquo;un element # On peut modifier les elements d\u0026rsquo;une liste deja existante comme suit :\nL = [1, 2, 3] L[0] = \u0026#34;hello\u0026#34; # La liste devient [\u0026#34;hello\u0026#34;, 2, 3] L[2] = True # La liste devient [\u0026#34;hello\u0026#34;, 2, True] L[3] = 5 # ERREUR list index out of range. Ajout et suppression d\u0026rsquo;element # Lorsqu\u0026rsquo;une liste existe, il est possible d\u0026rsquo;ajouter ou enlever un élément très facilement avec les fonctions pop et append :\nL = [1, 2, 3] L.append(5) # Ajout l\u0026#39;element 5 a la fin de la liste # Donnera [1, 2, 3, 5] L.pop(2) # Enleve l\u0026#39;element d\u0026#39;indice 2 # Donnera [1, 2, 5] L.pop() # Si on donne pas de parametre, pop enleve le dernier # Donnera [1, 2] L = L + [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] # concatenation de deux listes # Donnera [1, 2, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;] Taille d\u0026rsquo;une liste # Pour obtenir la taille d\u0026rsquo;une liste, on utilise la fonction len()\nL = [1, \u0026#39;a\u0026#39;, True] print(len(L)) # Affichera 3 L = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] print(len(L)) # Affichera 6 Les elements d\u0026rsquo;une liste L sont donc indexes de 0 a len(L)-1.\nPour acceder au dernier element d\u0026rsquo;une liste : L[len(L)-1]\nL = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] x = L[len(L)-1] print(x) # Affichera 23 Indexage negatif # Pour acceder aux elements de la liste, on peut utiliser l\u0026rsquo;indexage negatif. Dans ce cas les elements de la liste sont indexe du dernier element -1, au premier -len(L)\n# -6 -5 -4 -3 -2 -1 L = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] print(L[-2]) # Affichera 20 L\u0026rsquo;indexage negatif revient a retrancher len(L) de l\u0026rsquo;indice positif, par exemple l\u0026rsquo;element d\u0026rsquo;indice 0 peut aussi etre indexer par -len(L).\nPour acceder au dernier element d\u0026rsquo;une liste, on peut donc utiliser L[-1] au lieu de L[len(L)-1]\nMethodes et fonctions sur les listes # len(L) permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;elements d\u0026rsquo;une liste.\nL.append(e) permet d\u0026rsquo;ajouter l\u0026rsquo;element e a la fin de la liste.\nL.clear() permet de vider la liste.\nL.copy() permet de faire une copy de la liste\nL.count(e) permet de compter le nombre d\u0026rsquo;occurence de l\u0026rsquo;element e dans L\nL.extend(T) permet d\u0026rsquo;ajouter tous les elements de la liste T a la fin de la liste L\nL.index(e) renvoie l\u0026rsquo;indice de l\u0026rsquo;element e dans la liste L. Attention, la fonction donne une erreur si l\u0026rsquo;element n\u0026rsquo;est pas dans la liste.\nL.insert(i, e) permet d\u0026rsquo;inserer l\u0026rsquo;element e dans l\u0026rsquo;indice i.\nL.pop(i) permet d\u0026rsquo;enlever l\u0026rsquo;element d\u0026rsquo;indice i et le renvoie.\nL.remove(e) permet d\u0026rsquo;enlever l\u0026rsquo;element e de la liste si il exite. Attention, la fonction donne une erreur si l\u0026rsquo;element n\u0026rsquo;est pas dans la liste\nL.reverse() permet d\u0026rsquo;inverser l\u0026rsquo;ordre des elements dans la liste\nL.sort() permet de trier les elements de la liste. Pour cela les elements doivent etre du meme type.\nParcours d\u0026rsquo;une liste # On peut parcourir la liste comme suit :\nfor i in range(len(L)): print(\u0026#34;L\u0026#39;element d\u0026#39;indice\u0026#34;, i, \u0026#34;est\u0026#34;, L[i]) Ou encore :\nfor i in L: print(\u0026#34;L\u0026#39;element est\u0026#34;, i) Remarque: Si on parcourt une liste par for x in L, la variable x va iterer sur les éléments de L mais on n\u0026rsquo;a pas accès à l\u0026rsquo;indice de chaque élément. Par contre quand on utilise for i in range(len(L)), on peut acceder a l\u0026rsquo;element par L[i], ainsi que son indice i.\nLes tranches de listes # On peut prendre une partie d\u0026rsquo;une liste definie par un indice de debut d, indice de fin f, et le pas p utilise, avec la syntaxe : L[d:f:p] ou L[d:f] pour un pas de 1\nExemple # # 0 1 2 3 4 5 L = [2, \u0026#34;hello\u0026#34;, 3.5, True, 20, 23] print(L[1:3]) # Affichera [\u0026#34;hello\u0026#34;, 3.5] Si on omet l\u0026rsquo;indice de debut, la tranche commencera du debut de la liste. De meme, si on omet l\u0026rsquo;indice de fin, la tranche finira a la fin de la liste.\nprint(L[3:]) # [True, 20, 23] print(L[:2]) # [2, \u0026#34;hello\u0026#34;] print(L[3:0:-1]) # [True, 3.5, \u0026#34;hello\u0026#34;] print(L[::-1]) # permet d\u0026#39;inverser la liste Si les indices debut ou fin sont dans le mauvais ordre, on obtient une liste vide :\nprint(L[3:2]) # Affichera [] "},{"id":12,"href":"/fr/docs/sup/05-les_chaines/","title":"05 Les Chaines","section":"Sup","content":" Introduction # Une chaine de caractere est une variable qui contient du texte, un ensemble de caracteres qui se suivent dans un ordre précis. Elles sont définies entre guillemets (double quote) \u0026quot;, ou entre apostrophes (simple quote) '\nSyntaxe # L\u0026rsquo;identificateur (le nom) d\u0026rsquo;une chaine de caracteres suit les memes regles que les identificateurs de variables. On definit une chaine vide comme suit:\nma_chaine = \u0026#34;\u0026#34; autre_chaine = \u0026#39;\u0026#39; Sinon, une chaine de caracteres peut comporter des elements quelconques :\nnom = \u0026#34;Ahmed\u0026#34; ville = \u0026#39;Rabat\u0026#39; age = \u0026#34;20\u0026#34; message = \u0026#34;Bonjour tout le monde\u0026#34; On peut faire les operations de concatenation + et de repetition * sur une chaine de caracteres:\nch1 = \u0026#34;hello\u0026#34; ch2 = ch + \u0026#34; Ahmed\u0026#34; # Donnera la chaine \u0026#34;hello Ahmed\u0026#34; ch3 = ch1 * 3 # Donnera la chaine \u0026#34;hellohellohello\u0026#34; Les chaines de caracteres sont indexes de la meme maniere que les listes\n# 01234 \u0026lt;--- l\u0026#39;indice de chaque caractere ch = \u0026#34;hello\u0026#34; Pour acceder aux elements de la chaine de caracteres:\nch = \u0026#34;Bonjour tout le monde\u0026#34; print(ch[3]) # Affichera \u0026#34;j\u0026#34; print(ch[0]) # Affichera \u0026#34;B\u0026#34; print(ch[7]) # Affichera \u0026#34; \u0026#34; PS: les espaces sont aussi des caracteres et ont leurs propres indices.\nLes chaines sont non modifiable # title: [ Attention ],\n[\nAu contraire des listes ou on peut modifier les elements, les chaines de caractere sont non-modifiable ]\nch = \u0026#34;Bonjour\u0026#34; ch[1] = \u0026#34;a\u0026#34; # ERREUR Les chaines sont non modifiable Ajout d\u0026rsquo;un caractere # Pour ajouter un caractere a une chaine, on ne peut pas modifier la chaine, donc on cree une nouvelle chaine a partir de la concatenation de la chaine original et la chaine a ajouter\nch = \u0026#34;Bonjour\u0026#34; ch = ch + \u0026#34; tout le monde\u0026#34; # Donnera \u0026#34;Bonjour tout le monde\u0026#34; Taille d\u0026rsquo;une chaine # Pour obtenir la taille d\u0026rsquo;une chaine, on utilise la fonction len()\nch = \u0026#34;Bonjour\u0026#34; print(len(ch)) # Affichera 7 ch = \u0026#34; Bonjour \u0026#34; print(len(ch)) # Affichera 9 Les elements d\u0026rsquo;une chaine ch sont donc indexes de 0 a len(ch)-1.\nPour acceder au dernier element d\u0026rsquo;une chaine : ch[len(ch)-1]\nIndexage negatif # Pour acceder aux caracteres de la chaine, on peut utiliser l\u0026rsquo;indexage negatif. Dans ce cas les caracteres de la chaine sont indexe du dernier caractere -1, au premier -len(ch)\nch = \u0026#34;Bonjour\u0026#34; print(ch[-2]) # Affichera \u0026#34;u\u0026#34; L\u0026rsquo;indexage négatif revient a retrancher len(ch) de l\u0026rsquo;indice positif, par exemple le caractère d\u0026rsquo;indice 0 peut aussi être indexe par -len(ch).\nMéthodes et fonctions sur les chaines de caractere # len(ch) permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;elements d\u0026rsquo;une chaine.\nch.count(s) permet de compter le nombre d\u0026rsquo;occurence de la sous-chaine s dans ch\nch.find(s) renvoie l\u0026rsquo;indice de la sous-chaine s dans la chaine ch.\nch.replace(a, b) renvoie une nouvelle chaine ou la sous-chaine a est remplace par b\nch.strip() supprime les espaces inutiles au debut et a la fin de la chaine\nch.lower() convertit la chaine en minuscule\nch.upper() convertit la chaine en majuscule\nch.capitalize() convertit la premiere lettre de la chaine en majuscule\nch.isalpha() determine si la chaine est constitue que de lettres (renvoie True ou False)\nch.isdigit() determine si la chaine est constitue que de chiffres (renvoie True ou False)\nch.isupper() determine si la chaine est constitue que de majuscules (renvoie True ou False)\nch.islower() determine si la chaine est constitue que de minuscules (renvoie True ou False)\nParcours d\u0026rsquo;une chaine # On peut parcourir une chaine de caractere comme suit :\nfor i in range(len(ch)): print(i, ch[i]) Ou encore :\nfor i in ch: print(i) Les tranches de chaines # On peut prendre des tranches de chaines comme on fait pour les listes.\nUne tranche d\u0026rsquo;une chaine est definie par un indice de debut d, indice de fin f, et le pas p utilise, avec la syntaxe : ch[d:f:p] ou ch[d:f] pour un pas de 1\nExemple # ch = \u0026#34;Bonjour\u0026#34; print(ch[1:3]) # Affichera \u0026#34;on\u0026#34; Si on omet l\u0026rsquo;indice de debut, la tranche commencera du debut de la chaine. De meme, si on omet l\u0026rsquo;indice de fin, la tranche finira a la fin de la chaine.\nch = \u0026#34;Bonjour\u0026#34; print(ch[3:]) # \u0026#34;jour\u0026#34; print(ch[:2]) # \u0026#34;Bo\u0026#34; print(ch[3:0:-1]) # \u0026#34;jno\u0026#34; print(ch[::-1]) # permet d\u0026#39;inverser la chaine \u0026#34;ruojnoB\u0026#34; Si les indices debut ou fin sont dans le mauvais ordre, on obtient une chaine vide :\nprint(ch[3:2]) # Affichera \u0026#34;\u0026#34; "},{"id":13,"href":"/fr/docs/sup/06-les_tris/","title":"06 Les Tris","section":"Sup","content":" Algorithmes de tri # Énoncé du problème # On souhaite réordonner une collection d\u0026rsquo;elements suivant une relation d\u0026rsquo;ordre déterminée. On peut, sans perte de generalite, simplifier l\u0026rsquo;etude des differentes methodes de tri en se limitant aux listes d\u0026rsquo;entiers, qu\u0026rsquo;on souhaite trier par ordre croissant.\nIl s\u0026rsquo;agit donc d\u0026rsquo;elaborer une fonction tri(L) qui prend en parametre une liste d\u0026rsquo;entier L et qui permet de trier cette liste, et de renvoyer la liste triee.\ndef tri(L): # ... return L # Programme de test L = [9, 5, 8, 1, 12, 4] tri(L) print(L) Dans toute la suite, on pose $n = \\text{ len}(L)$.\nTri par selection # Le tri par selection consiste a selectionner dans chaque iteration le prochain element a placer dans la liste triee, qui est le minimum des elements non encore tries. C\u0026rsquo;est a dire, en faisant varier $i$ de $0$ a $n$, a chaque iteration, on va remetre le $i^{\\text{eme}}$ element de la liste triee, qui est min(L[i:n]), a sa place L[i].\nImplementation # def tri_selection(L): for i in range(len(L)-1): indice_min = i for j in range(i+1,len(L)): if L[j] \u0026lt; L[indice_min]: indice_min = j L[i],L[indice_min] = L[indice_min],L[i] Complexite # On a deux boucles imbriquées, la boucle intérieure comporte des instructions de complexité $O(1)$, et se répète n-i fois, la boucle exterieure se repete pour i=0 a i=n, donc la complexite est $O\\left( n^{2} \\right)$.\nTri par insertion # Le tri par insertion consiste a inserer, un par un, les elements de la liste non triee dans la liste triee.\nImplementation # def insertionSort(L): for i in range(1, len(L)): cle = L[i] j = i-1 while j \u0026gt;= 0 and cle \u0026lt; L[j] : L[j + 1] = L[j] j -= 1 L[j + 1] = cle Complexite # La complexite de la boucle interieure depend de l\u0026rsquo;etat de la liste.\nAu meilleur des cas : La liste est deja triee, la boucle while ne s\u0026rsquo;execute pas. Complexite $O(n)$.\nAu pire des cas : La liste est triee a l\u0026rsquo;ordre inverse, la boucle while se repete i fois, donc la complexite est $O\\left( n^{2} \\right)$.\nTri a bulles # Le tri a bulles consiste a faire plusieurs passages de comparaisons deux-a-deux, ou on va echanger deux elements si il ne sont pas au bon ordre. Les elements vont se deplacer petit a petit jusqu\u0026rsquo;a trouver leurs places. Ce deplacement global des elements ressemble aux deplacements de bulles qui remontent dans un liquide.\nImplementation # def bubbleSort(L): n = len(L) for i in range(n): for j in range(0, n-i-1): if L[j] \u0026gt; L[j+1]: L[j], L[j+1] = L[j+1], L[j] Complexite # La complexite est $O\\left( n^{2} \\right)$\nTri par fusion # Le tri par fusion est un tri recursif, ou on decoupe la liste en deux, on trie chaque partie a l\u0026rsquo;aide d\u0026rsquo;un appel recursif, puis on fusionne les deux listes triees en une seule liste finale.\nImplementation # def fusion(L, R): i = j = 0 S = [] while i \u0026lt; len(L) and j \u0026lt; len(R): if L[i] \u0026lt;= R[j]: S.append(L[i]) i += 1 else: S.append(R[j]) j += 1 while i \u0026lt; len(L): S.append(L[i]) i += 1 while j \u0026lt; len(R): S.append(R[j]) j += 1 return S def tri_fusion(L): if len(L) \u0026lt;= 1: return L mid = len(L)//2 L1 = L[:mid] L2 = L[mid:] L1 = tri_fusion(L1) L2 = tri_fusion(L2) return fusion(L1, L2) Complexite # La complexite $C(n)$ verifie la relation de recurrence : $C(n) = 2C\\left( \\frac{n}{2} \\right) + O(n)$\nLa complexite est donc $O\\left( n\\log(n) \\right)$\nTri Rapide # Le tri rapide (ou tri pivot) est un tri recursif qui consiste a choisir un element pivot p suivant lequel on decoupe la liste en deux listes : L1 les elements inferieurs au pivot, et L2 les elements superieurs au pivot, on trie alors chaque partie a l\u0026rsquo;aide d\u0026rsquo;un appel recursif, la liste totale triee est donc : L1 + [p] + L2.\nImplementation # def quick_sort(L): if len(L) \u0026lt;= 1: return L pivot = L[0] L1=[] L2=[] for i in range(1,len(L)): if L[i] \u0026lt;= p : L1.append(L[i]) if L[i] \u0026lt; p : L2.append(L[i]) return quick_sort(L1) + [p] + quick_sort(L2) Complexite # On note $C(n)$ la complexite de la fonction quick_sort(L), avec n = len(L)\nLa boucle for a une complexite de $O(n)$\nLe cout des appels recursifs quick_sort(L1) et quick_sort(L2) depend des longeurs des listes L1 et L2:\nAu pire des cas : Le pivot est le plus grand (ou plus petit) element de la liste, L1 et L2 auront les tailles n-1 et 0, donc : $$C(n) = O(n) + C(n-1) + C(0)$$ Ce qui donne $$C(n) = O(n^2)$$\nAu meilleur des cas : Le pivot est au milieu de la liste, les listes L1 et L2 sont de taille a peu pres n/2, donc : $$C(n) = O(n) + 2C(n/2)$$ Ce qui donne $$C(n) = O(nlog(n))$$\n"},{"id":14,"href":"/fr/docs/sup/07-tuples_dictionnaires_ensembles/","title":"07 Tuples Dictionnaires Ensembles","section":"Sup","content":" Introduction # Les listes et les chaines de caracteres sont une maniere d\u0026rsquo;organiser et de structurer les donnees. On peut egalement organiser les donnees dans d\u0026rsquo;autres structures de donnees. Chaque structure presente differents avantages et inconvenients suivant les situations.\nLes Tuples # Syntaxe # L\u0026rsquo;identificateur (le nom) d\u0026rsquo;un tuple suit les memes regles que les identificateurs de variables. On definit un tuple comme suit:\nT = () T2 = (1,) # La virgule est importante quand il y\u0026#39;a un seul element T3 = (1, \u0026#34;hello\u0026#34;, 3.14, True) On peut faire les operations de concatenation + et de repetition * sur un tuple\nt1 = (1, 2, 3) t2 = t1 + (4, 5) # Donnera (1, 2, 3, 4, 5) t3 = t1 * 2 # Donnera (1, 2, 3, 1, 2, 3) Les tuples sont indexes de la meme maniere que les listes\n# 0 1 2 3 \u0026lt;- indices T = (1, \u0026#34;hello\u0026#34;, 3.14, True) Pour acceder aux elements du tuple :\nprint(T[3]) # Affichera True print(T[0]) # Affichera 1 print(T[1]) # Affichera \u0026#34;hello\u0026#34; Les tuples sont non modifiable # title: [ Attention ], [\nAu contraire des listes ou on peut modifier les elements, les tuples sont non-modifiable ]\nT = (1, 2, 3) T[0] = 2 # ERREUR Les tuples sont non modifiable Indexage negatif # Pour acceder aux elements du tuple, on peut utiliser l\u0026rsquo;indexage negatif. Dans ce cas les caracteres de la chaine sont indexe du dernier caractere -1, au premier -len(T)\n# -4 -3 -2 -1 \u0026lt;- indices T = (1, \u0026#34;hello\u0026#34;, 3.14, True) print(T[-2]) # Affichera 3.14 L\u0026rsquo;indexage negatif revient a retrancher len(T) de l\u0026rsquo;indice positif, par exemple l\u0026rsquo;element d\u0026rsquo;indice 0 peut aussi etre indexe par -len(T).\nMethodes et fonctions sur les tuples # len(T) permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;elements d\u0026rsquo;un tuple.\nT.count(e) permet de compter le nombre d\u0026rsquo;occurence de l\u0026rsquo;element e dans T\nT.index(e) donne l\u0026rsquo;indice de la premiere occurence de l\u0026rsquo;element e dans T\ne in T donne True si le tuple T contient l\u0026rsquo;element e, False sinon.\nParcours d\u0026rsquo;un tuple # On peut parcourir un tuple comme suit :\nfor i in range(len(T)): print(i, T[i]) Ou encore :\nfor i in T: print(i) Les tranches de tuples # On peut prendre des tranches de tuples comme on fait pour les listes.\nUne tranche d\u0026rsquo;un tuple est definie par un indice de debut d, indice de fin f, et le pas p utilise, avec la syntaxe : T[d:f:p] ou T[d:f] pour un pas de 1\nExemple # T = (1, \u0026#34;hello\u0026#34;, 3.14, True) print(T[1:3]) # Affichera (\u0026#34;hello\u0026#34;, 3.14) Si on omet l\u0026rsquo;indice de debut, la tranche commencera du debut du tuple. De meme, si on omet l\u0026rsquo;indice de fin, la tranche finira a la fin du tuple. Si les indices debut ou fin sont dans le mauvais ordre, on obtient une chaine vide.\nLes Dictionnaires # Definition # Un dictionnaire est un ensemble de couples cle - valeur. Pour definir un dictionnaire :\nd = {} # dictionnaire vide d1 = {\u0026#34;nom\u0026#34;:\u0026#34;Ahmed\u0026#34;, \u0026#34;age\u0026#34;: 18 } d2 = {1 :3, 2 : 9, 3: 81} # Les espaces n\u0026#39;ont pas d\u0026#39;effet. Acces, modification, suppression # On peut acceder a une valeur a partir de sa cle :\nd1 = {\u0026#34;nom\u0026#34;:\u0026#34;Ahmed\u0026#34;, \u0026#34;age\u0026#34;: 18 } d2 = {1 :3, 2 : 9, 3: 81} print(d1[\u0026#34;nom\u0026#34;]) # Affichera \u0026#34;Ahmed\u0026#34; print(d2[3]) # Affichera 81 On peut ajouter un nouveau couple cle-valuer ou modifier la valeur d\u0026rsquo;une cle dans un dictionnaire comme suit :\nd1 = {\u0026#34;nom\u0026#34;:\u0026#34;Ahmed\u0026#34;, \u0026#34;age\u0026#34;: 18 } d2 = {1 :3, 2 : 6, 3: 9} d1[\u0026#34;age\u0026#34;] = 20 d1[\u0026#34;age\u0026#34;] += 1 d2[4] = 12 Pour supprimer un couple cle-valeur :\nd2 = {1 :3, 2 : 6, 3: 9} del d2[1] # Le dictionnaire devient {2:6, 3:9} Operations sur les dictionnaires # len(d) permet d\u0026rsquo;obtenir le nombre de couple cle-valeur dans un dictionnaire.\nd.clear() permet de vider le dictionnaire\ncle in d test si cle est une cle dans le dictionnaire d (retourne un boolean)\nfor cle in d permet d\u0026rsquo;iterer sur les cles du dictionnaire\nd.items() donne la liste des couples cle-valeur du dictionnaire d\nd.keys() donne la liste des cles du dictionnaire d\nd.values donne la liste des valeurs du dictionnaire d\nLes ensembles # Definition # Un ensemble est une collection d\u0026rsquo;elements sans ordre, sans repetitions.\nOn definit un ensemble a partir d\u0026rsquo;une liste d\u0026rsquo;elements :\nE = set() # ensemble vide F = set([1, 5, 2, 3, 1]) print(F) # Affiche {1, 2, 3, 5} Operation sur les ensembles # len(E) : permet d\u0026rsquo;obtenir le nombre d\u0026rsquo;element de l\u0026rsquo;ensemble E\nE.add(e) : Ajoute l\u0026rsquo;element e a l\u0026rsquo;ensemble E\nE | F : donne l\u0026rsquo;union de $E \\cup F$\nE \u0026amp; F : donne l\u0026rsquo;intersection $E \\cap F$\nE - F : donne la difference $E - F$\n"}]